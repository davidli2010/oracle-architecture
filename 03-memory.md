# 内存结构

Oracle的3个主要内存结构：
- 系统全局区（System Global Are, SGA）：这是一个大的共享内存段，几乎所有Oracle进程都要访问这个区域。
- 进程全局区（Process(or Program) Global Area, PGA）：这是一个进程或线程专用的内存，其他进程/线程不能访问。
- 用户全局区（User Global Area, UGA）：这个内存区与特定的会话相关联。它可能在SGA中分配，也可能在PGA中分配，这取决于是用共享服务器还是用专用服务器来连接数据库。如果使用共享服务器，UGA就在SGA中分配；如果使用专用服务器，UGA就会在PGA中。

## 进程全局区和用户全局区
 
 PGA（进程全局区）是特定于进程的一段内存。换句话说，它是操作系统中某个进程或线程专用的内存，不允许系统中的其它进程或线程访问。PGA一般是通过malloc()或memmap()来分配，而且可以在运行时动态扩大（或收缩）。PGA绝对不会在Oracle的SGA中分配，而总是由进程或线程为自身分配。

 UGA（用户全局区）实际上来说，就是你的会话的状态。它是一段你的会话一直能访问到的内存。UGA的分配位置完全取决于你如何连接Oracle。

 从Oracle9iR1起，有两个办法来管理PGA中的这些非UGA内存：
 - 手动PGA内存管理，采用这种方法时，你要告诉Oracle，如果一个进程中需要排序或散列，允许使用多少内存来完成这些排序或散列。
 - 自动PGA内存管理，这要求你告诉Oracle，PGA在系统范围内可以尝试使用多少内存。

 从Oracle11gR1开始，自动PGA内存管理可以使用以下两种技术实现：
 - 通过设置PGA_AGGREGATE_TARGET初始化参数，告诉Oracle在实例范围内PGA可以尝试使用多少内存。
 - 通过设置MEMORY_TARGET初始化参数，告诉Oracle实例应当允许SGA和PGA总共使用多大内存。数据库自己根据这个参数确定合适的PGA大小。

有几个问题经常被问道：“内存是怎么分配的？”以及“我的会话使用了多少内存？”这些问题很难回答。可以根据MetaLink 147806.1和223730.1中的一些信息来做一些分析：
- PGA_AGGREGATE_TARGET是一个上限目标，而不是启动数据库时预分配的内存大小。
- 某个具体的会话所能使用的PGA内存量也依赖于PGA_AGGREGATE_TARGET的设置。相关算法所能确定的一个进程可用内存的最大值，这会随数据库版本而变化。通常情况下，一个进程分配到的PGA可用内存量是根据可用内存总量和正在争用内存的进程数来确定的。
- 随着服务器上工作负载的增加，分配给各个工作区的PGA内存量会减少。数据库会努力保证所有PGA分配的总和不超过PGA_AGGREGATE_TARGET设置的阈值，但是如果实在无法限制，它就会被迫超量使用来保证数据库的运行。

## 系统全局区

每个Oracle数据库实例都有一个很大的内存结构，成为系统全局区（System Global Area, SGA）。这是一个大型的共享内存结构，每个Oracle进程都会访问它。

SGA内分为多个不同的池（pool），以下是其中主要的：
- Java池（Java pool）：Java池是为数据库中运行的Java虚拟机所分配的一段固定大小的内存。Java池可以在数据库启动和运行时动态调整大小。
- 大池（large pool）：在使用共享服务器连接时存放会话内存（UGA），在使用并行执行功能时作为消息缓冲区，在RMAN备份时作为磁盘I/O缓冲区。大池可以动态调整大小。
- 共享池（shared pool）：共享池包含共享游标（shared cursor）、存储过程、状态对象、字典缓存和诸如此类的大量其它数据。共享池可以动态调整大小。
- 流池（streams pool）：这是一个专门针对数据传输/共享工具的内存池。可以动态调整大小。
- “空”池（"Null" pool）：这个池其实没有名字。它是块缓冲区（用来缓存数据库块）、重做日志缓冲区和“固定SGA”区专用的内存。
