# 分区

分区（partitioning）可以将一个表或索引物理地分解为多个更小、更易管理的部分。尽管分区表、索引可能由数十个物理分区组成，但就访问数据库的应用而言，它访问的是逻辑上的一个表或索引。每个分区都是一个独立的对象，我们可以单独处理，也可以将其作为一个更大对象的一部分进行处理。

## 分区概述

分区使用了一种“分而治之”的方法，适于管理非常大的表和索引。分区引入了一种分区键（partition key）的概念。数据会根据其分区键值分到相应的分区。划分分区的方法可以是基于键值的某个范围、或者是键值的一个列表，也可以是分区键值的某个散列函数值。下面列出分区的几个好处：
- 提高数据的可用性：这对任何类型的系统都适用，而不论系统本质上是OLTP还是数据仓库系统。
- 将大段（segment）分解成小段，从而减轻管理的负担：如果我们在一个100GB的表上执行管理操作，与在各个10GB的表分区上执行10次同样的操作相比，前者负担要大得多。另外，通过使用分区，我们还可以在删除数据时完全不留下碎片空间，此时就根本不需要重组表！
- 改善某些查询的性能：这主要针对大型仓库环境。通过使用分区，我们可以跳过某些分区的数据，从而将需要访问、处理的数据精简到一个很小的范围。但这在事务性系统中并不适用，因为这种系统本身就只是访问少量的数据。
- 可以把数据的修改分布到多个分区上，从而减少高负荷OLTP系统上的竞争：如果应用对某个段的争用非常严重，我们可以把它分为多个段，这就能成比例地减少争用。

### 提高可用性

可用性的提高来源于每个分区的独立性。表（索引）中一个分区的可用性（或不可用性）不会影响表（索引）本身的可用性。如果你的表（索引）是分区的，那么查询优化器就会意识到这点，并且在执行计划中去除不需要的分区。比如说一个大对象中的一个分区不可用，而你的查询又不需要这个分区，那么Oracle还是能成功地处理这个查询。

### 减少管理负担

分区机制之所以能减少管理负担，是因为与在一个大对象上执行操作相比，在小对象上执行同样的操作更为容易、速度更快，而且占用的资源也更少。

### 增强语句性能

分区的第三个好处是它能够增强一些SQL语句（SELECT、INSERT、UPDATE、DELETE、MERGE）的性能，这些SQL分为两类，一类是修改信息的语句，另一类是读取信息的语句。

1. 并行DML  
数据库中的修改数据的语句都能以并行的方式执行（并行DML，PDML）。当它以PDML方式执行时，Oracle会使用多个线程或进程来执行INSERT、UPDATE、DELETE或MERGE，而不是以单进程方式串行地执行。在一个有充足I/O带宽的多CPU主机上，这样的大规模DML操作所带来的速度提升可能会相当显著。
2. 查询性能  
在提升只读查询（SELECT语句）的性能方面，分区会使用下面两种特殊的操作：
    - 分区修剪（partition elimination）：处理查询时不考虑某些分区内的数据。
    - 并行操作（parallel partition）：并行全表扫描和并行索引区间扫描就是这种操作的例子。不过，能在多大程度上收益于上面这两种操作取决于所用系统的类型。
        - OLTP：在OLTP系统中，不应该把分区当作一种大幅改善查询性能的方法。
        - 数据仓库系统: 在一个数据仓库/决策支持系统中，分区不仅是一个很强大的管理工具，还可以加快处理的速度。
        - 降低OLTP系统上的争用
        分区的最后一个优势就是降低OLTP系统上的争用，从而增强系统的并发处理能力。

## 表分区机制

目前在Oracle中有9种对表分区的方法：
- 区间分区（range partitioning）：可以指定某个区间的数据应该应该放在一起。
- 散列分区（hash partitioning）：数据库会在一个列（或多个列）上应用一个散列函数，每行数据都会按其散列值放在相应的分区中。
- 列表分区（list partitioning）：指定一个离散值集，来确定应当存储在一起的数据。
- 间隔分区（interval partitioning）：与区间分区非常相似，区别在于数据库可以在数据到来时创建新的分区。
- 引用分区（reference partitioning）：对于一对外键约束的父/子表，如果父表已分区，子表可以通过外键约束来继承父表的分区方式，子表上的这种分区方法称为引用分区。
- 间隔引用分区（interval reference partitioning）：这种分区是间隔分区和引用分区的组合。它能给引用分区表自动增加新分区。
- 虚拟列分区（virtual column partitioning）：可以使用表中一列或几列的表达式来分区，表中的每一行并不存放分区表达式的值，表达式只存在元数据中。
- 组合分区（composite partitioning）：这是区间分区、散列分区和列表分区的组合。通过组合分区，可以先按照某种方式分区，再按照另外某种方式对每个分区内的数据划分子分区。
- 系统分区（system partitioning）：应用来决定将数据写入哪一个分区。

### 行移动

如果修改分区键会发生什么情况。关于这个问题，需要考虑两点：
- 数据修改之后，它仍属于原来的分区。这种修改在所有的分区机制中都没有问题。
- 数据修改之后，更新后的分区键值属于另外一个分区；按照各分区定义，这样的数据需要跨分区移动。只有当表启用了行移动时，这样的数据修改才能成功（即数据会跨分区移动），否则Oracle会报错。

## 索引分区

索引与表类似，也可以分区。对索引分区有以下两种方法：
- 按表分区的方式对索引分区：这也称为本地索引（local index）。每个表分区都有一个索引分区，而且这个索引分区只会对这个表分区中的数据进行索引。同一索引分区中的所有条目都指向一个表分区，同一表分区中的所有行都会放在一个索引分区中。
- 按区间或散列对索引分区：这也称为全局分区索引（globally partitioned index）。当我们采用这种分区方式时，索引可以按区间分区（在Oracle10g以及更高版本中也可以按散列分区），一个索引分区可能指向任何（和所有）表分区。

如果在分区表上想使本地索引来支撑UNIQUE约束或者PRIMARY KEY约束，那么必须要将分区键加到这个约束中去。
