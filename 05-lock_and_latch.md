# 锁和闩

## 什么是锁

锁（lock）用于管理对共享资源的并发访问。

## 锁的问题

### 丢失更新

丢失更新（lost update）是一个经典的数据库问题。实际上，所有多用户计算机环境都存在这个问题。简单地说，出现下面的情况时（按以下所列的顺序），就会发生丢失更新。
1. 会话Session1中的一个事务获取（查询）了一行数据，放入本地内存，并显示给一个最终用户，User1。
2. 会话Session2中的另一个事务也获取了这一行，并将数据显示给另一个最终用户，User2。
3. User1使用应用修改了这一行，并让应用更新数据库并提交。会话Session1中的事务现在已经完成。
4. User2也修改了这一行，并让应用更新数据库并提交。会话Session2中的事务现在已经完成。

这个过程成为“丢失更新”，因为第3步所做的所有修改都会丢失。

### 悲观锁

悲观锁（pessimistic locking）这种方式在用户修改数值之前就已经开始生效了。悲观锁仅适用于有状态（stateful）或有连接（connected）环境。也就是说，你的应用与数据库之间有一个持续的连接，而且只有你一个人在使用这条连接（至少是在事务的生命周期内）。

### 乐观锁

第二种方法称为乐观锁（optimistic locking），即把所有锁定的动作都延迟到即将执行更新之前才进行。换句话说，我们会修改屏幕上的信息二不需要先锁住它。这种锁定方法在所有环境下都行得通，但是采用这种方法的话，更新“失败”的可能性会加大。也就是说，用户要更新它的数据行时，却发现数据已经被修改过，那他就必须从头再来。

### 阻塞

如果一个会话持有某个资源的锁，而另一个会话在请求这个资源，就会出现阻塞（blocking）。这样一来，请求的会话会被阻塞，它会“挂起”，直至持有锁的会话放弃锁定的资源。在几乎所有的情况下，阻塞都是可以避免的。

数据库中有5个常见的DML语句可能会引起阻塞，它们是：INSERT、UPDATE、DELETE、MERGE和SELECT FOR UPDATE。对于一个阻塞的SELECT FOR UPDATE，解决方案很简单：只需增加NOWAIT子句，它就不会阻塞了。这样一来，应用会向最终用户报告，这一行已经锁定。

1. 阻塞的INSERT  
INSERT阻塞的情况不多见。最常见的情况是：你有一个带主键的表，或者表上有唯一性约束，但有两个会话试图用同样的值插入一行。如果是这样，其中一个会话就会阻塞，直到另一个会话提交或者回滚为止：如果另一个会话提交，那么阻塞的会话会收到一个错误，指出存在一个重复值；倘若另一个会话回滚，在这种情况下，阻塞的会话则会成功。还有一种情况，可能多个表通过引用完整性约束相互链接。对子表的插入可能会阻塞，如果它所依赖的父表中的行正在被创建或删除。
2. 阻塞的MERGE、UPDATE和DELETE  
在一个交互式应用中，可以从数据库查询数据，允许最终用户处理这些数据，再把它“放回”到数据库中。此时如果发生UPDATE或DELETE阻塞，就说明代码中可能存在一个丢失更新问题。通过使用SELECT FOR UPDATE NOWAIT查询可以避免这个问题。这个查询能做到：
    - 验证自从你查询数据之后数据未被修改（防止丢失更新）；
    - 锁住行（防止UPDATE或DELETE被阻塞）。  
不论是悲观锁还是乐观锁都可以利用SELECT FOR UPDATE NOWAIT查询来验证行未被修改。

### 死锁

如果有两个会话，每个会话都持有另一个会话想要的资源，此时就会出现死锁（deadlock）。

### 锁升级

出现锁升级（lock escalation）时，系统会降低锁的粒度。举例来说，数据库系统会把一个表的100个行级锁变成一个表级锁。现在你用的是“能锁住全部行的一个锁”，通常，这还会锁住以前没有锁定的大量数据。当锁被认为是数据库中的一种稀缺资源而且要避免维护大量锁的开销时，锁升级就会被使用。

Oracle从来不会升级锁，但是它会执行锁转换（lock conversion）或锁提升（lock promotion），这些词通常会与锁升级混淆。

Oracle会尽可能地尝试使用最低级别的锁（也就是说，限制最少的锁），如有必要，再把这个锁转换为一个受限更多的级别。例如，如果用FOR UPDATE子句从表中选择一行，就会创建两个锁。一个锁放在所选的行上（这是一个排他锁；其他任何人都不能再以排他的模式锁定这一行）。另一个锁是ROW SHARE TABLE锁，放在表本身上。这个锁能防止其他会话在表上再放置一个排他锁，举例来说，这样能相应地防止这些会话改变表的结构。另一个会话可以修改这个表中的任何其他行，而不会有冲突。这样，尽管表中有一行被锁住，但还是能在表上成功地执行尽可能多的命令。

## 锁类型

在Oracle中主要有3类锁：
- DML锁：DML锁机制允许并发执行数据修改。例如，DML锁可能是特定数据行上的锁，或者是锁定表中所有行的表级锁。
- DDL锁：DDL锁可以保护对象结构定义。
- 内部锁和闩：Oracle使用这些锁来保护其内部数据结构。

### DML锁

DML锁用于确保一次只有一个人能修改某一行，而且这时别人不能删除这个表。在你工作时，Oracle多少会以比较透明的方式为你加这些锁。

#### 1. TX锁

事务发起第一个修改时会得到TX锁（事务锁）。事务的发起是自动的。TX锁会被一直持有，直至事务执行提交（COMMIT）或回滚（ROLLBACK）。TX锁被用作一种排队机制，使得其它会话可以等待这个事务完成。事务中修改或通过SELECT FOR UPDATE选择的任何行都会“指向”该事务的一个相关事务锁。

这听上去开销很大，但实际上并非如此。在Oracle中，锁是作为数据的一个属性被保存的。Oracle并没有一个传统的锁管理器以及锁管理器为系统中锁定的每一行维护的一个长长的列表。

在Oracle中的锁定过程如下所示：  
（1）找到想锁定的那一行的地址；  
（2）到达那一行；  
（3）就地锁住这一行，就是在行的位置上，而非某个大列表（如果这一行已经被锁住，则等待锁住它的事务结束，除非使用了NOWAIT选项）。

由于锁是数据的一个属性，所以Oracle不需要传统的锁管理器。在Oracle中对数据行锁定时，行指向事务ID的一个副本，事务ID存储在包含数据的块中，释放锁时，事务ID却会保留下来。另一个会话到来时，它会看到事务ID，由于事务ID表示一个事务，所以可以很快地查看持有这个锁的事务是否还是活动的。如果锁是不活动的，则允许会话访问这个数据。如果锁还是活动的，会话就会要求一旦释放锁就得到通知。因此，这就有了一个排队机制：请求锁的会话会排队，等待目前拥有锁的事务执行，然后得到数据。

#### 2. TM（DML Enqueue）锁

TM锁用于确保在修改表的内容时，表的结构不会改变。例如，如果你已经更新了一个表中的行，那同时也会得到这个表上的一个TM锁。这会防止另一个用户在该表上执行DROP或ALTER命令。

尽管每个事务只能得到一个TX锁，但是TM锁则不同，修改了多少个对象，就能得到多少个TM锁。

### DDL锁

在DDL操作中会自动为对象加DDL锁，从而保护这些对象不会被其它会话所修改。例如，如果执行一个DDL操作ALTER TABLE T，通常表T上就会加上一个排它DDL锁，一防止其它会话得到这个表的DDL锁和TM锁。

有以下3种类型的DDL锁：
- 排它DDL锁（exclusive DDL lock）：这会防止其它会话得到它们自己的DDL锁或TM锁。这说明，在DDL操作期间可以查询一个表，但是无法以任何方式修改这个表。
- 共享DDL锁（share DDL lock）：这些锁会保护所引用的对象的结构，使之不会被其它会话修改，但是允许修改数据。
- 可中断解析锁（breakable parse lock）：这些锁允许一个对象（如共享池中缓存的一个查询计划）向其它对象注册其依赖性。如果在被依赖的对象上执行DDL，Oracle会查看已经注册的依赖对象列表，并使这些依赖对象无效。因此，这些锁是”可中断的“，它们不能阻止DDL的出现。

大多数DDL都会带有一个排他DDL锁。

### 闩

闩（latch）是轻量级的串行设备，用于协调对共享数据结构、对象和文件的多用户访问。

闩就是一种为保护极短时间而设计的锁（例如，修改一个内存中数据结构所需的时间）。闩用于保护某些内存结构，如数据库块缓冲区缓存或共享池中的库缓存。一般会在内部以一种”愿意等待“（willing to wait）模式请求闩。

Oracle使用诸如”测试和设置“（test and set）以及”比较和交换“（compare and swap）之类的原子指令来处理闩。闩只保持很短的时间，而且提供了一种清理机制，万一某个闩持有者异常地”死掉了“，就能执行清理。这个清理过程由PMON执行。

### 互斥锁

互斥锁（mutex）是一种与闩非常类似的串行化设备，它的名字源于”相互排斥“（mutual exclusion）。互斥锁与闩的区别在于，互斥锁的实现更加轻量级。实现它所使用的代码更少，它包含的指令数大约只有闩的1/5，使用的内存也更少，大约是闩的1/7。

### 手动锁定和用户定义锁

#### 1. 手动锁定

SELECT ... FOR UPDATE语句就是手动锁定数据的一种主要方法。

还可以使用LOCK TABLE语句手动地锁定数据。

#### 2. 创建自己的锁

通过DBMS_LOCK包，Oracle实际上向开发人员开放了它在内部使用的队列锁机制。
