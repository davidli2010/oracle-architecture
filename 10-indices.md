# 索引

## 概述

Oracle提供了多种不同类型的索引：
- B\*Tree索引：这是Oracle和大多数其它数据库中最常用的索引。B\*Tree的构造类似于二叉树，通过键值就能快速地访问一行数据，或通过键值的某个范围内来定位多行数据；通过这种索引访问数据一般只需要几个I/O就能完成。这里需要重点注意，B\*Tree中的B不代表二叉（binary），而代表平衡（balanced）。B\*Tree索引并不是一颗二叉树。除了普通的B\*Tree索引之外，以下几种类型也算是B\*Tree索引。
    - 索引组织表（index organized table）：这是一种表，但它的存储也是B\*Tree结构。IOT中的数据要按主键来存储和排序。
    - B\*Tree聚簇索引（B\*Tree cluster index）：这是传统B\*Tree索引的一个近似变体。B\*Tree聚簇索引是对聚簇键建立的索引。在传统的B\*Tree索引中，键会指向行这一级别；而B\*Tree聚簇不同，一个聚簇键会指向一个块，这个块中包含与这个聚簇键相关的数据。
    - 降序索引（descending index）：在降序索引中，数据是按“从大到小”的顺序（降序）来排列的，而不是按“从小到大”（升序）。
    - 反向键索引（reverse key index）：这也是B\*Tree索引，只不过键中的字节会“反转”。如果向一个索引中不断插入递增的数据，那么这些数据通过反向键索引会得到更均匀的分布。Oracle将数据放入索引之前，先把待存储数据的字节反转，这样原先可能在索引中相邻位置放置的数据，在字节反转之后就会相距很远。通过反转字节，就能将索引上的插入分布到多个块上。
- 位图索引（bitmap index）：在一棵B\*Tree中，通常索引条目和行之间存在一对一的关系：一个索引条目指向一行数据。而对于位图索引，一个索引条目会通过一个位图同时指向多行数据。位图索引适用于高度重复的数据（高度重复是指相对于表中的总行数，数据只有很少的几个不同值），而且数据通常是只读的。
- 位图联结索引（bitmap join index）：数据的逆规范化通常是通过表来实现的，而这种索引也能对数据进行逆规范化。
- 基于函数的索引（function-based index）：这些索引本身就是B*Tree索引或位图索引，但是存储的是某列或某几个列的一个计算结果，而不是原始的列数据。可以将这种类型的索引看成是虚拟列（或派生列）上的索引。
- 应用域索引（application domain index）：应用域索引是你自己构建和存储的索引，它可能存储在Oracle中，也可能在Oracle之外。你要告诉优化器索引的选择性如何，以及执行的开销有多大，优化器则会根据你提供的信息来决定是否使用你的索引。

## B\*Tree索引

B\*Tree索引是数据库中最常见的一类索引结构，其实现与二叉查找树很相似。它的目标是尽可能减少Oracle搜索数据所花费的时间。

这个数最底层的块成为叶节点（leaf node）或叶块（leaf block），其中包含各个索引键以及一个rowid（指向所索引的行）。叶节点之上的内部块称为分支块（branch block），数据的搜索会通过这种块最终抵达叶节点。

索引叶节点这一层的结构实际上是一个双向链表。如果我们要搜索位于某个范围内的数据（也称为索引区间扫描，index range scan），那么一旦取到起始的叶节点（范围内的第一个值），那接下来的工作就容易得多了。此时不必再从头扫描索引结构，而只需通过叶节点向前或向后扫描就可以了。

B\*Tree的特点之一是：所有叶块都应该在树的同一层上。这一层也称为索引的高度（height），所有从索引的根块到叶块的遍历都会访问同样数目的块。索引是高度平衡的（height balanced）。大多数B\*Tree索引的高度都是2或者3，即使索引中有数百万行记录也是如此。这说明，通过索引找到第一个叶块只需2到3次I/O。

### 反向键索引

这种索引是为了特定的环境以及特定的问题而设计的，其主要目的是为了减少“右手”索引中索引叶块的竞争，有助于缓解缓冲区忙等待问题。

### 降序索引

在降序索引中，列中的数据是以降序（从大到小）的方式存储的，而不是升序（从小到大）。在Oracle8i之前，尽管语法上也支持DESC（降序）关键字，但是数据库一般都会将其忽略，这个关键字对于索引中数据如何存储或使用没有任何影响。在Oracle8i之后的版本中，DESC关键字确实会改变索引的创建和使用方式。

### 什么情况下应该使用B\*Tree索引

- 如果要访问表中非常少的一部分数据，那就用B\*Tree索引；
- 如果要处理表中大量的数据，但这些数据可以通过索引直接拿到，那就用B\*Tree索引。

上面这两条给出了两种使用索引的方法：
- 访问表中的行：通过索引来访问表中的数据，前提是要访问的数据只占表的很小一部分。
- 回答一个查询：索引包含了足够的信息来回答整个查询，根本不用去访问表。查询此时把索引看成是表的一个精简版本。

## 位图索引

位图索引是为数据仓库/即席查询（ad hoc query）而设计的，特别不适用于OLTP系统；如果系统中的数据会由多个并发会话频繁地更新，那么也不该用位图索引。

位图索引的结构与B\*Tree索引不同，它的一个索引键条目会指向多行数据；而在B\*Tree索引中，索引键和表中的行存在一对一的关系。位图索引的索引条目可能会很少，但是每个索引条目指向多行；而在传统的B\*Tree中，一个索引条目就指向一行数据。

### 什么情况下应该使用位图索引

位图索引对于相异基数（distinct cardinality）低的数据最为合适（也就是说，与整个数据集的总数相比，这个数据只有很少几个不同的值）。对此进行量化是不太可能的，一般来说，数据中不同值的个数除以总行数如果是一个很小的数（接近于0）才算是低相异基数。

B\*Tree索引一般来讲应当是具有高度选择性的。与之相反，位图索引不该具有那么高的选择性，而是一般没有选择性。

### 位图联结索引

通常情况下，索引都是建立在一个表上的，而且只会用到这个表上的列；位图联结索引则打破了这个规则，它在一个表上建立的索引基于另外一个表的某个列。实际上，通过这种位图联结索引我们就能将数据在索引中（而不是在表中）进行逆规范化。

使用位图联结索引有一个先决条件：联结条件必须是联结到另一个表中的主键或唯一键。

## 基于函数的索引

可以通过基于函数的索引，来对某些列经过计算之后的结果进行索引，并在查询中直接使用索引中的计算结果。简而言之，通过基于函数的索引，可以做很多事情，如执行不区分大小写的搜索或排序，根据复杂的公式进行搜索；你还可以实现自己的函数和运算符，然后在此之上执行搜索从而高效地执行SQL语言。

使用基于函数的索引可能有很多原因，其中主要的原因如下：
- 这种索引很容易实现，而且其中的值都是计算好的，在需要的时候能够立即用上；
- 不用修改任何逻辑或查询，就可以加快现有应用的速度。

### 只对部分行建立索引

基于函数的索引除了对使用内置函数（如UPPER、LOWER等）的查询有帮助之外，还可以用来索引表的一部分数据（行）。

对于一个B\*Tree索引，如果表中某行数据的索引列全部为空值（NULL），那么索引中就没有针对这条数据的索引条目。

采用基于函数的索引，可以编写一个函数：如果不想对某行数据加索引，那就让这个函数给这行返回NULL；而对想加索引的行则返回一个非NULL值。

## 应用域索引

应用域索引（application domain index）即Oracle所谓的可扩展索引（extensible indexing）。利用应用域索引，你可以创建自己的索引结构，使之像Oracle提供的索引一样工作。利用应用域索引，可以实现数据库中原本没有的新索引类型。

## 不可见的索引

从Oracle11g起，可以将某个索引标记为invisible（不可见），这样优化器就看不到这个索引了。这里的不可见仅仅是指，查询优化器生成的执行计划不会用到这个索引。可以创建一个invisible的索引，也可以将一个visible的索引改为invisible。

## 同列上的多个索引

自12c起，可以在同样的列（及列组合）上创建多个索引，但这么做有一个前提条件：这些索引必须是物理上完全不同的。例如，如果在某列上先创建了一个B\*Tree索引，那么接下来就只能创建位图索引。此外，相同列上的索引只能有一个为可见的。
