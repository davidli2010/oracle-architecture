# redo和undo

redo（重做信息）是Oracle在线（或归档）重做日志文件中记录的信息，当数据库发生故障时，可以利用这些数据来”重放“（或重做）事务。undo（回滚信息）是Oracle在undo段中记录的信息，它主要用于取消或回滚事务。

## 什么是redo

重做日志文件（redo log file）对Oracle数据库来说至关重要，它们是数据库的事务日志。Oracle维护着两类重做日志文件：在线（online）重做日志文件和归档（archived）重做日志文件。这两类重做日志文件都用于恢复，其主要目的是，当出现数据库实例失败或介质失败时，它们就能派上用场。

归档重做日志文件实际上就是已填满的“旧”在线重做日志文件的副本。当数据库写满在线重做日志文件时，ARCn进程会在另一个位置建立它的副本，当然它也可以在本地或者远端服务器上保留多个副本。

每个Oracle数据库都至少有两个在线重做日志组，每个组中至少有一个成员（重做日志文件），这些在线重做日志组会以循环的方式使用。Oracle会先写组1中的日志文件，当写到组1中文件的最后时，它将切换到日志文件组2，开始写这个组中的文件。等到日志文件组2写满时，Oracle将会再次切换回日志文件组1.

重做日志可能是数据库中最重要的恢复结构，不过，如果没有其它部分（如undo段、分布式事务恢复等），单靠重做日志什么也做不了。

## 什么是undo

从概念上讲，undo正好与redo相对。对数据执行修改时，数据库会生成undo信息，以便将来需要的时候可以把数据变更回修改之前的状态。多版本机制就是通过使用这些undo信息来实现的。此外，当执行的事务或语句由于某种原因失败的时候，或者你用一条ROLLBACK语句请求回滚时，Oracle也需要利用这些undo信息将数据恢复到修改前的样子。redo用于在失败时重放事务（即恢复事务），undo则用于取消一条语句或一组语句的作用。与redo不同，undo是存储在数据库内部一组特殊的段中，称为undo段。

通常有人会对undo有一个误解，他们认为undo会将数据库“物理地”恢复到某个语句或事务之前的样子，但实际上并非如此。数据库只是“逻辑地”将数据恢复到原来的样子，某些修改会被被“逻辑地”取消，但是数据结构以及数据库块本身在回滚后可能（与事务或语句开始之前的数据块状态）大不相同。原因在于：在所有多用户系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要功能之一就是协调它们对数据的并发访问。事务修改的块，很有可能同时也正被其它的事务修改。因此，不能简单地将一个块放回到事务开始前的样子，这样会撤销其它事务的工作！

## redo和undo如何协作

尽管undo信息存储在undo表空间和undo段中，但它也会受到redo的保护。换句话说，数据库会把undo当成是表数据或索引数据一样处理，对undo的修改会生成一些redo，这些redo将记入日志缓冲区进而写到日志文件中。与数据库中的非undo数据类似，undo数据会写入到undo段中，而且也会被放到缓冲区缓存中。

### INSERT-UPDATE-DELETE-COMMIT示例场景

#### 1.INSERT
INSERT发生后，块缓冲区缓存里面存放着修改完的undo块、索引块和表数据块，所有的这些块都被重做日志缓冲区中相应条目所“保护”。

在将修改过的数据块刷到磁盘之前，先把重做日志缓冲区的redo信息写到磁盘上去，这样一旦发生宕机，就可以通过这些redo信息来重做所有修改，从而将SGA回放到现在的状态，进而数据库也有相应的undo信息以对未提交的事务进行回滚。

#### 2.INSERT
UPDATE的运作与INSERT大体一样，不过UPDATE生成的UNDO量更大；这是由于UPDATE需要保存数据修改前的映像。数据库块缓冲区中又有了一些新的undo块，以及修改过的表及索引块。UPDATE语句也生成了一些新的redo放在重做缓冲区。

实例恢复的整个恢复过程是分成两步完成的：首先前滚，把系统重放到失败点上，然后回滚所有尚未提交的工作。这个过程会再次同步数据文件。它会重放已经进行的工作，并撤销尚未完成的所有工作。

当应用发出ROLLBACK命令时，Oracle会去查找这个事务的undo信息，它可能在缓存的undo的块中（通常是这样），也可能已经刷新输出到磁盘上（对于非常大的事务，就往往是这种情况）。接下来Oracle会把undo信息应用到缓冲区缓存中的数据和索引块上，或者倘若数据和索引块已经不在缓存中，则要从磁盘将数据和索引块读入缓存，再对其应用undo。这些块会恢复为其原来的状态，并在以后会被刷新输出到数据文件。

需要注意，回滚过程中从不会涉及到重做日志，只有恢复和归档时才会读取重做日志。这对于调优意义重大：重做日志是用来写的，不是用来读的，Oracle不会在正常的处理中读取重做日志。

#### 3.DELETE
同样，DELETE会生成undo，块将被修改，并把redo发送到重做日志缓冲区，这与前面没有太大的不同。

#### 4.COMMIT
当事务提交时，Oracle会把重做日志缓冲区刷新输出到磁盘。

## 提交和回滚处理

### COMMIT做什么

通常情况下，COMMIT是一个非常快的操作，其时间与事务大小无关。不论事务有多大，COMMIT的响应时间一般都很“稳定”，这是因为COMMIT并没有太多的工作去做，不过它所做的确实至关重要。

COMMIT的开销主要来自两方面：
- 客户端与数据库之间的往返通信量将会显著增大。如果我们为每行记录都提交，那么我们就会生成大量的往返通信。
- 每次提交时，都必须等待redo写至磁盘。在这种情况下，一种被称为日志文件同步（log file sync）的等待事件将会显著地降低系统性能。

为什么COMMIT的响应时间不会随着事务的大小而改变呢？这是因为在数据库中执行COMMIT之前，困难的工作都已经做了。我们已经修改了数据库中的数据，所以99.9%的工作都已经完成。例如，已经发生了如下操作：
- 已经在SGA中生成了undo块；
- 已经在SGA中生成了已修改数据块；
- 已经在SGA中生成了对应前两项的redo缓存；
- 如果前三项比较大并且耗时较长，那这三项中的某些数据可能已经被刷新输出到磁盘；
- 已经得到了所需的全部锁。

执行COMMIT时，只剩下如下的工作：
- 为事务生成一个SCN（System Change Number）。SCN是Oracle使用的一种简单的计时机制，用于保证事务的顺序，并支持失败恢复。此外它还用于数据库中的读一致性和检查点。
- LGWR将所有未写入磁盘的重做日志条目写至磁盘，并把SCN记录到在线重做日志文件中。这一步就是真正的COMMIT，如果提交过程走到了这一步，事务的状态就是已提交。此时事务条目会从V$TRANSACTION中被“删除”。
- V$LOCK中会记录着会话持有的锁，这些锁都将被释放，而排队等待这些锁的会话都会被唤醒，从而可以继续完成它们的工作。
- 如果事务修改的某些块还在缓冲区缓存中，Oracle就会以一种快速的模式访问并“清理”。块清除是指清除存储在数据库块首部的与锁相关的信息，实际上它是在清除块上的事务信息，这样下一个访问这个块的人就不用这么做了。这个清理过程不会生成重做日志信息，这样可以省去以后的大量工作。

### ROLLBACK做什么

和COMMIT一样，ROLLBACK也包含一系列的动作。为了完整地展现ROLLBACK过程，我们先复习一下在这之前数据库所做的工作：
- 已经在SGA中生成了undo块。
- 已经在SGA中生成了已修改数据块。
- 已经在SGA中生成了对应前两项的redo缓存。
- 如果前三项比较大并且耗时较长，那这三项中的某些数据可能已经输出到磁盘。
- 已经得到了所需的全部锁。

ROLLBACK时，还要做如下工作：
- 撤销所有修改。Oracle数据库会读取undo段，然后将undo数据应用到数据块以撤销修改，并将相应的undo条目标记为已应用。如果先前插入了一行，ROLLBACK会将其删除；如果更新了一行，回滚就会取消更新；如果删除了一行，回滚将把它再次插入。
- 会话持有的所有锁都将被释放，如果有会话在排队等待我们持有的锁，就会被唤醒。
